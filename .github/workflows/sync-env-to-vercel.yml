name: Sync Environment Variables to Vercel

on:
  workflow_dispatch: # Manual trigger
    inputs:
      environment:
        description: "Environment to sync to"
        required: true
        type: choice
        options:
          - production
          - preview
          - development
      confirm:
        description: 'Type "sync" to confirm'
        required: true
  push:
    branches:
      - main  # Syncs to production (sensitive secrets included)
      - staging  # Syncs to preview (sensitive secrets EXCLUDED - only public vars)
    paths-ignore:
      - "**.md"
      - ".github/workflows/**"

jobs:
  sync-env:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'push' || 
      (github.event_name == 'workflow_dispatch' && github.event.inputs.confirm == 'sync')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "env=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/staging" ]; then
            echo "env=preview" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Staging branch detected - sensitive secrets will NOT be synced (preview only)"
          else
            echo "env=production" >> $GITHUB_OUTPUT
            echo "‚úÖ Production branch detected - sensitive secrets will be synced"
          fi

      - name: Sync GitHub Secrets to Vercel
        run: |
          set +e  # Don't exit on error - we'll handle errors manually
          # Sync environment variables from GitHub Secrets to Vercel
          # Uses Change Data Capture (CDC) approach: only sync variables that don't exist

          export VERCEL_TOKEN="${{ secrets.VERCEL_TOKEN }}"
          export VERCEL_ORG_ID="${{ secrets.VERCEL_ORG_ID }}"
          export VERCEL_PROJECT_ID="${{ secrets.VERCEL_PROJECT_ID }}"
          TARGET_ENV="${{ steps.env.outputs.env }}"

          echo "üîÑ Syncing environment variables to $TARGET_ENV..."
          echo "üìã Project ID: $VERCEL_PROJECT_ID"
          echo "üìã Org ID: $VERCEL_ORG_ID"

          # Verify Vercel CLI is working
          vercel --version || echo "‚ö†Ô∏è  Vercel CLI check failed"

          # Step 1: Fetch existing variables from Vercel (Change Data Capture)
          # Use Vercel REST API directly since CLI doesn't support --json flag
          echo ""
          echo "üìã Fetching existing Vercel environment variables for $TARGET_ENV..."

          # Use Vercel REST API to get environment variables as JSON
          # API endpoint: GET /v9/projects/{id}/env
          EXISTING_VARS_JSON=""
          FETCH_EXIT_CODE=0

          # Map environment names to API values
          case "$TARGET_ENV" in
            production)
              API_ENV="production"
              ;;
            preview)
              API_ENV="preview"
              ;;
            development)
              API_ENV="development"
              ;;
            *)
              API_ENV="production"
              ;;
          esac

          # Fetch using Vercel REST API
          EXISTING_VARS_JSON=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer $VERCEL_TOKEN" \
            "https://api.vercel.com/v9/projects/$VERCEL_PROJECT_ID/env?target=$API_ENV" \
            2>&1) || {
            FETCH_EXIT_CODE=$?
            echo "‚ö†Ô∏è  Failed to fetch environment variables via API (exit code: $FETCH_EXIT_CODE)"
          }

          # Extract HTTP status code (last line) and response body
          HTTP_CODE=$(echo "$EXISTING_VARS_JSON" | tail -n1)
          EXISTING_VARS_JSON=$(echo "$EXISTING_VARS_JSON" | sed '$d')

          # Check if API call was successful (HTTP 200)
          if [ "$HTTP_CODE" != "200" ]; then
            FETCH_EXIT_CODE=1
            echo "‚ö†Ô∏è  API returned HTTP $HTTP_CODE"
            if [ -n "$EXISTING_VARS_JSON" ]; then
              echo "   Response: $(echo "$EXISTING_VARS_JSON" | head -3)"
            fi
          fi

          # Check if fetch was successful
          USE_FALLBACK_MODE=false
          # Check for errors in output (but don't fail if grep fails)
          HAS_ERROR=false
          echo "$EXISTING_VARS_JSON" | grep -qi "error\|unauthorized\|forbidden" 2>/dev/null && HAS_ERROR=true || true

          if [ $FETCH_EXIT_CODE -ne 0 ] || [ -z "$EXISTING_VARS_JSON" ] || [ "$EXISTING_VARS_JSON" == "[]" ] || [ "$HAS_ERROR" = "true" ]; then
            echo "‚ö†Ô∏è  Could not fetch existing variables (exit code: $FETCH_EXIT_CODE), will use fallback mode (--force)"
            if [ $FETCH_EXIT_CODE -ne 0 ]; then
              echo "   Error output: $(echo "$EXISTING_VARS_JSON" | head -5)"
            fi
            USE_FALLBACK_MODE=true
            EXISTING_VARS=""
            EXISTING_COUNT=0
          else
            # Extract variable names from JSON output (Vercel API returns { envs: [...] })
            if command -v jq >/dev/null 2>&1; then
              # Try both formats: direct array or { envs: [...] }
              EXISTING_VARS=$(echo "$EXISTING_VARS_JSON" | jq -r 'if type == "object" and has("envs") then .envs[].key else .[].key end' 2>/dev/null | sort || echo "")
            else
              # Fallback: use grep/awk if jq is not available
              # Try to extract from both formats
              EXISTING_VARS=$(echo "$EXISTING_VARS_JSON" | grep -o '"key":"[^"]*"' | sed 's/"key":"\([^"]*\)"/\1/' | sort || echo "")
            fi

            if [ -z "$EXISTING_VARS" ]; then
              echo "‚ö†Ô∏è  No existing variables found, will sync all"
              USE_FALLBACK_MODE=true
              EXISTING_COUNT=0
            else
              EXISTING_COUNT=$(echo "$EXISTING_VARS" | grep -c . || echo "0")
              echo "‚úÖ Found $EXISTING_COUNT existing variables in $TARGET_ENV"
              if [ "$EXISTING_COUNT" -lt 10 ]; then
                echo "   Existing: $(echo "$EXISTING_VARS" | tr '\n' ' ')"
              fi
            fi
          fi

          # Function to check if variable exists
          var_exists() {
            local var_name=$1
            if [ "$USE_FALLBACK_MODE" = "true" ] || [ -z "$EXISTING_VARS" ]; then
              return 1  # No existing vars list, assume it doesn't exist (will use --force)
            fi
            echo "$EXISTING_VARS" | grep -q "^${var_name}$"
          }

          # Track sync statistics
          SYNCED_COUNT=0
          SKIPPED_COUNT=0
          MISSING_SECRET_COUNT=0

          # Function to add env var if secret exists and variable doesn't exist in Vercel
          sync_var() {
            local var_name=$1
            local secret_value=$2
            local env_type=$3
            
            if [ -z "$secret_value" ]; then
              echo "‚è≠Ô∏è  Skipping $var_name (not set in GitHub Secrets)"
              MISSING_SECRET_COUNT=$((MISSING_SECRET_COUNT + 1))
              return 2  # Return code 2 = missing secret
            fi
            
            # Check if variable already exists in Vercel
            if var_exists "$var_name"; then
              echo "‚è≠Ô∏è  Skipping $var_name (already exists in $env_type)"
              SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
              return 1  # Return code 1 = skipped (exists)
            fi
            
            # Variable doesn't exist, sync it
            echo ""
            echo "üì§ Syncing $var_name to $env_type..."
            
            # Use --force flag if we're in fallback mode (couldn't fetch existing vars)
            if [ "$USE_FALLBACK_MODE" = "true" ]; then
              OUTPUT=$(echo "$secret_value" | vercel env add "$var_name" "$env_type" \
                --token="$VERCEL_TOKEN" \
                --scope="$VERCEL_ORG_ID" \
                --force \
                2>&1)
            else
              OUTPUT=$(echo "$secret_value" | vercel env add "$var_name" "$env_type" \
                --token="$VERCEL_TOKEN" \
                --scope="$VERCEL_ORG_ID" \
                2>&1)
            fi
            EXIT_CODE=$?
            
            if [ $EXIT_CODE -eq 0 ]; then
              echo "‚úÖ $var_name successfully synced to $env_type"
              SYNCED_COUNT=$((SYNCED_COUNT + 1))
              return 0  # Return code 0 = synced successfully
            else
              # Check if it's just "already exists" or similar informational message
              # Use || true to prevent grep from causing script to exit
              if echo "$OUTPUT" | grep -qi "already exists\|already added\|already present\|updated\|added" 2>/dev/null; then
                echo "‚ÑπÔ∏è  $var_name already exists in $env_type (race condition or manual update)"
                SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
                return 1  # Return code 1 = skipped (exists)
              else
                echo "‚ö†Ô∏è  Warning: Issue syncing $var_name (exit code: $EXIT_CODE):"
                echo "$OUTPUT" | head -10
                echo "   Continuing with other variables..."
                # Don't fail the entire workflow - just log and continue
                return 0
              fi
            fi
          }

          # ‚ö†Ô∏è  SECURITY: Sync sensitive secrets ONLY to production
          # Staging/preview environments should NOT receive production secrets
          # Staging secrets must be manually configured in Vercel Dashboard
          if [ "$TARGET_ENV" == "production" ]; then
            echo ""
            echo "üîê Syncing sensitive secrets to PRODUCTION only..."
            sync_var "SUPABASE_SERVICE_ROLE_KEY" "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" "$TARGET_ENV"
            sync_var "STRIPE_SECRET_KEY" "${{ secrets.STRIPE_SECRET_KEY }}" "$TARGET_ENV"
            sync_var "STRIPE_WEBHOOK_SECRET" "${{ secrets.STRIPE_WEBHOOK_SECRET }}" "$TARGET_ENV"
            sync_var "RESEND_API_KEY" "${{ secrets.RESEND_API_KEY }}" "$TARGET_ENV"
            sync_var "CRON_SECRET" "${{ secrets.CRON_SECRET }}" "$TARGET_ENV"
            sync_var "CRON_JOB_ORG_API_KEY" "${{ secrets.CRON_JOB_ORG_API_KEY }}" "$TARGET_ENV"
            sync_var "OPENAI_API_KEY" "${{ secrets.OPENAI_API_KEY }}" "$TARGET_ENV"
            sync_var "CALENDAR_ENCRYPTION_KEY" "${{ secrets.CALENDAR_ENCRYPTION_KEY }}" "$TARGET_ENV"
            sync_var "GOOGLE_CLIENT_ID" "${{ secrets.GOOGLE_CLIENT_ID }}" "$TARGET_ENV"
            sync_var "GOOGLE_CLIENT_SECRET" "${{ secrets.GOOGLE_CLIENT_SECRET }}" "$TARGET_ENV"
            sync_var "OUTLOOK_CLIENT_ID" "${{ secrets.OUTLOOK_CLIENT_ID }}" "$TARGET_ENV"
            sync_var "OUTLOOK_CLIENT_SECRET" "${{ secrets.OUTLOOK_CLIENT_SECRET }}" "$TARGET_ENV"
            sync_var "OUTLOOK_TENANT_ID" "${{ secrets.OUTLOOK_TENANT_ID }}" "$TARGET_ENV"
            sync_var "NEXT_PUBLIC_GLITCHTIP_DSN" "${{ secrets.NEXT_PUBLIC_GLITCHTIP_DSN }}" "$TARGET_ENV"
            sync_var "NEXT_PUBLIC_UMAMI_URL" "${{ secrets.NEXT_PUBLIC_UMAMI_URL }}" "$TARGET_ENV"
            sync_var "NEXT_PUBLIC_UMAMI_WEBSITE_ID" "${{ secrets.NEXT_PUBLIC_UMAMI_WEBSITE_ID }}" "$TARGET_ENV"
            
            # Stripe Price IDs (non-sensitive but should be in secrets for consistency)
            sync_var "STRIPE_PRICE_ID_STANDARD_MONTHLY" "${{ secrets.STRIPE_PRICE_ID_STANDARD_MONTHLY }}" "$TARGET_ENV"
            sync_var "STRIPE_PRICE_ID_STANDARD_YEARLY" "${{ secrets.STRIPE_PRICE_ID_STANDARD_YEARLY }}" "$TARGET_ENV"
            sync_var "STRIPE_PRICE_ID_PROFESSIONAL_MONTHLY" "${{ secrets.STRIPE_PRICE_ID_PROFESSIONAL_MONTHLY }}" "$TARGET_ENV"
            sync_var "STRIPE_PRICE_ID_PROFESSIONAL_YEARLY" "${{ secrets.STRIPE_PRICE_ID_PROFESSIONAL_YEARLY }}" "$TARGET_ENV"
            echo "‚úÖ Production secrets sync completed"
          else
            echo ""
            echo "‚ö†Ô∏è  SKIPPING sensitive secrets for $TARGET_ENV (preview/staging)"
            echo "   Staging secrets must be manually configured in Vercel Dashboard"
            echo "   This prevents production secrets from being exposed to staging"
          fi

          # Sync public variables (safe for all environments - production, preview, development)
          sync_var "NEXT_PUBLIC_SUPABASE_URL" "${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}" "$TARGET_ENV"
          sync_var "NEXT_PUBLIC_SUPABASE_ANON_KEY" "${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}" "$TARGET_ENV"
          sync_var "NEXT_PUBLIC_APP_URL" "${{ secrets.NEXT_PUBLIC_APP_URL }}" "$TARGET_ENV"

          # Note: If NEXT_PUBLIC_APP_URL is not set, the app uses fallback: https://nextbestmove.app

          echo ""
          echo "üìä Sync Summary:"
          echo "   ‚úÖ Synced: $SYNCED_COUNT new variables"
          echo "   ‚è≠Ô∏è  Skipped: $SKIPPED_COUNT existing variables"
          if [ "$MISSING_SECRET_COUNT" -gt 0 ]; then
            echo "   ‚ö†Ô∏è  Missing secrets: $MISSING_SECRET_COUNT variables (not set in GitHub Secrets)"
          fi
          echo "   üìã Total existing in Vercel: $EXISTING_COUNT variables"

          echo ""
          echo "üìä Verifying synced variables..."
          # Suppress telemetry notice
          VERCEL_TELEMETRY_DISABLED=1 vercel env ls "$TARGET_ENV" \
            --token="$VERCEL_TOKEN" \
            --scope="$VERCEL_ORG_ID" \
            2>&1 | grep -v "telemetry\|NOTE:\|Vercel CLI" | head -20 || echo "‚ö†Ô∏è  Could not list environment variables"

          echo ""
          echo "‚úÖ Environment variable sync completed for $TARGET_ENV"
          echo "üìù Note: Review Vercel Dashboard to ensure all variables are set correctly"
          echo "üîÑ Trigger a redeploy in Vercel to apply new environment variables"

          # Exit with success if we synced at least one variable or skipped some
          # This ensures the workflow doesn't fail if some variables already exist
          if [ $SYNCED_COUNT -gt 0 ] || [ $SKIPPED_COUNT -gt 0 ]; then
            exit 0
          else
            # If nothing was synced or skipped, check if we had missing secrets
            if [ $MISSING_SECRET_COUNT -gt 0 ]; then
              echo "‚ö†Ô∏è  Warning: No variables synced, but some secrets were missing"
              exit 0  # Still succeed - missing secrets is not a failure
            else
              echo "‚ö†Ô∏è  Warning: No variables were synced or skipped"
              exit 0  # Still succeed - might be first run or all vars already exist
            fi
          fi
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
